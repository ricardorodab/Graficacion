#LyX 2.1 created this file. For more info see http://www.lyx.org/
\lyxformat 474
\begin_document
\begin_header
\textclass article
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_math auto
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Graficacion por Computadora
\begin_inset Newline newline
\end_inset

Tarea 1 OpenGL Fractales
\end_layout

\begin_layout Author
José Ricardo Rodríguez Abreu
\end_layout

\begin_layout Date
03/15/16
\end_layout

\begin_layout Section*
1.
 Algoritmo de la Alfombra de Sierpinski
\end_layout

\begin_layout Standard

\lang spanish-mexico
Para este fractal usé dos clases:
\end_layout

\begin_layout Standard

\lang spanish-mexico
La clase punto lo único que tiene es dos vértices que son X y Y.
 Me sirve para localizar los puntos de un cuadrado.
\end_layout

\begin_layout Standard

\lang spanish-mexico
La clase Alfombra lo que contiene es un constructor que incluye 4 vértices.
 Los vértices que recibe marca el primer cuadro, que es el caso base de
 nuestra recursión.
 Dependiendo de que tantos niveles de nuestro fractal deseemos será las
 cantidades de veces que recursamos.
\end_layout

\begin_layout Standard

\lang spanish-mexico
Lo interesante de este clase es el método draw que recibe 7 parámetros:
\end_layout

\begin_layout Standard

\lang spanish-mexico
Next es nivel de recursión que se hará en el fractal.
\end_layout

\begin_layout Standard

\lang spanish-mexico
4 puntos que son donde se encuentra nuestro cuadrado actual.
\end_layout

\begin_layout Standard

\lang spanish-mexico
Un número flotante dif que nos ayuda para saber el tamaño de los siguientes
 cuadrados que se dibujan en la siguiente iteración.
\end_layout

\begin_layout Standard

\lang spanish-mexico
Quitar es un booleano que no dice si una vez que pasemos por un nivel, hay
 que dibujar de blanco el último nivel de la recursión.
\end_layout

\begin_layout Standard

\lang spanish-mexico
Básicamente nuestro método dibuja el cuadrado con nuestro 4 puntos, encuentra
 el centro de los siguiente 8 cuadrados y para cada uno de ellos, con el
 centro y nuestro parámetro dif, encuentra los 32 puntos de la siguiente
 iteración para poder dibujarlos.
\end_layout

\begin_layout Standard

\lang spanish-mexico
Para este fractal se usaron 2 archivos (3 incluyendo el main) y 2 clases.
\end_layout

\begin_layout Subsection*
Alfombra.h (Declaración de funciones y clases)
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

/* ------------------------------------------------------------------- 
 
\end_layout

\begin_layout Plain Layout

* Alfombra.h 
\end_layout

\begin_layout Plain Layout

* versión 1.0
\end_layout

\begin_layout Plain Layout

* Copyright (C) 2016   
\end_layout

\begin_layout Plain Layout

* José Ricardo Rodríguez Abreu,
\end_layout

\begin_layout Plain Layout

* Facultad de Ciencias, 
\end_layout

\begin_layout Plain Layout

* Universidad Nacional Autónoma de México, Mexico.
 
\end_layout

\begin_layout Plain Layout

*  
\end_layout

\begin_layout Plain Layout

* Este programa es software libre; se puede redistribuir  
\end_layout

\begin_layout Plain Layout

* y/o modificar en los términos establecidos por la  
\end_layout

\begin_layout Plain Layout

* Licencia Pública General de GNU tal como fue publicada 
\end_layout

\begin_layout Plain Layout

* por la Free Software Foundation en la versión 2 o  
\end_layout

\begin_layout Plain Layout

* superior.
  
\end_layout

\begin_layout Plain Layout

*  
\end_layout

\begin_layout Plain Layout

* Este programa es distribuido con la esperanza de que  
\end_layout

\begin_layout Plain Layout

* resulte de utilidad, pero SIN GARANTÍA ALGUNA; de hecho  
\end_layout

\begin_layout Plain Layout

* sin la garantía implícita de COMERCIALIZACIÓN o  
\end_layout

\begin_layout Plain Layout

* ADECUACIÓN PARA PROPÓSITOS PARTICULARES.
 Véase la  
\end_layout

\begin_layout Plain Layout

* Licencia Pública General de GNU para mayores detalles.
  
\end_layout

\begin_layout Plain Layout

*  
\end_layout

\begin_layout Plain Layout

* Con este programa se debe haber recibido una copia de la  
\end_layout

\begin_layout Plain Layout

* Licencia Pública General de GNU, de no ser así, visite el  
\end_layout

\begin_layout Plain Layout

* siguiente URL:  * http://www.gnu.org/licenses/gpl.html  
\end_layout

\begin_layout Plain Layout

* o escriba a la Free Software Foundation Inc.,  
\end_layout

\begin_layout Plain Layout

* 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
  
\end_layout

\begin_layout Plain Layout

* -------------------------------------------------------------------  */
 
\end_layout

\begin_layout Plain Layout

#include <cstdlib> 
\end_layout

\begin_layout Plain Layout

#include <cmath> 
\end_layout

\begin_layout Plain Layout

#include <iostream> 
\end_layout

\begin_layout Plain Layout

#include <GL/glew.h> 
\end_layout

\begin_layout Plain Layout

#ifdef __APPLE__ 
\end_layout

\begin_layout Plain Layout

# define __gl_h_ 
\end_layout

\begin_layout Plain Layout

# define GL_DO_NOT_WARN_IF_MULTI_GL_VERSION_HEADERS_INCLUDED 
\end_layout

\begin_layout Plain Layout

#endif 
\end_layout

\begin_layout Plain Layout

//#include "Dependencies
\backslash
freeglut
\backslash
freeglut.h"
\end_layout

\begin_layout Plain Layout

// cambienlo de acuerdo a como ustedes lo tengan 
\end_layout

\begin_layout Plain Layout

#include <OpenGL/gl3.h> 
\end_layout

\begin_layout Plain Layout

#define __gl_h_ 
\end_layout

\begin_layout Plain Layout

#include <GL/freeglut.h>
\end_layout

\begin_layout Plain Layout

#include <GL/glut.h> 
\end_layout

\begin_layout Plain Layout

#include <vector>
\end_layout

\begin_layout Plain Layout

//#include "Dependencies
\backslash
glew
\backslash
glew.h"
\end_layout

\begin_layout Plain Layout

//cambienlo de acuerdo a como ustedes lo tengan 
\end_layout

\begin_layout Plain Layout

//#include "Dependencies
\backslash
freeglut
\backslash
freeglut.h"
\end_layout

\begin_layout Plain Layout

// cambienlo de acuerdo a como ustedes lo tengan
\end_layout

\begin_layout Plain Layout

using namespace std;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/**  
\end_layout

\begin_layout Plain Layout

* Definimos una clase punto.
  
\end_layout

\begin_layout Plain Layout

*/
\end_layout

\begin_layout Plain Layout

class Punto {   
\end_layout

\begin_layout Plain Layout

/**    
\end_layout

\begin_layout Plain Layout

* Atributos x, y del punto.
    
\end_layout

\begin_layout Plain Layout

*/  
\end_layout

\begin_layout Plain Layout

private:   float x,y;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/**    
\end_layout

\begin_layout Plain Layout

* Constructor y métodos.
    
\end_layout

\begin_layout Plain Layout

*/  
\end_layout

\begin_layout Plain Layout

public:  
\end_layout

\begin_layout Plain Layout

Punto(float x, float y); 
\end_layout

\begin_layout Plain Layout

float getX();   
\end_layout

\begin_layout Plain Layout

float getY();   
\end_layout

\begin_layout Plain Layout

void setX(float x);   
\end_layout

\begin_layout Plain Layout

void setY(float y); 
\end_layout

\begin_layout Plain Layout

};
\end_layout

\begin_layout Plain Layout

/**  
\end_layout

\begin_layout Plain Layout

* Definimos nuestra clase alfombra que será el fractal.
  
\end_layout

\begin_layout Plain Layout

*/ 
\end_layout

\begin_layout Plain Layout

class Alfombra {
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/*
\end_layout

\begin_layout Plain Layout

*    
\end_layout

\begin_layout Plain Layout

* Aquí van los atributos y los métodos privados.
   
\end_layout

\begin_layout Plain Layout

*/  
\end_layout

\begin_layout Plain Layout

private:   
\end_layout

\begin_layout Plain Layout

unsigned int level;   
\end_layout

\begin_layout Plain Layout

Punto *p1,*p2,*p3,*p4;   
\end_layout

\begin_layout Plain Layout

void draw(int next,Punto *p1, Punto *p2, Punto *p3, Punto *p4,float dif,bool
 quitar);
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

/**    
\end_layout

\begin_layout Plain Layout

* Métodos contructores y de la clase.
    
\end_layout

\begin_layout Plain Layout

*/  
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

public:   
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Alfombra(int level,Punto 
\end_layout

\begin_layout Plain Layout

*p1, Punto *p2, Punto *p3, Punto *p4);   
\end_layout

\begin_layout Plain Layout

int getLevel();   
\end_layout

\begin_layout Plain Layout

void setLevel(int level);     
\end_layout

\begin_layout Plain Layout

void draw(int next);   
\end_layout

\begin_layout Plain Layout

void quita_ultimo_nivel(int next); 
\end_layout

\begin_layout Plain Layout

}; //Fin de Alfombra.h
\end_layout

\end_inset


\end_layout

\begin_layout Subsection*
Alfombra.cpp (Implementación de draw)
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

/**  
\end_layout

\begin_layout Plain Layout

* Método privado para dibujar los niveles del fractal.
  
\end_layout

\begin_layout Plain Layout

*/ 
\end_layout

\begin_layout Plain Layout

void Alfombra::draw(int next,
\end_layout

\begin_layout Plain Layout

Punto *p1, 
\end_layout

\begin_layout Plain Layout

Punto *p2,
\end_layout

\begin_layout Plain Layout

Punto *p3, 
\end_layout

\begin_layout Plain Layout

Punto *p4,
\end_layout

\begin_layout Plain Layout

float dif,
\end_layout

\begin_layout Plain Layout

bool quitar) 
\end_layout

\begin_layout Plain Layout

{   
\end_layout

\begin_layout Plain Layout

if(next == 0)
\end_layout

\begin_layout Plain Layout

    return; 
\end_layout

\begin_layout Plain Layout

 if(quitar && next == 1)  
\end_layout

\begin_layout Plain Layout

  {     
\end_layout

\begin_layout Plain Layout

glColor3f(255,255,255);   
\end_layout

\begin_layout Plain Layout

 }  
\end_layout

\begin_layout Plain Layout

else  
\end_layout

\begin_layout Plain Layout

 {     
\end_layout

\begin_layout Plain Layout

glColor3f(0,0,0);     
\end_layout

\begin_layout Plain Layout

}   
\end_layout

\begin_layout Plain Layout

glBegin(GL_POLYGON);        
\end_layout

\begin_layout Plain Layout

glVertex2f(p1->getX(),p1->getY());   
\end_layout

\begin_layout Plain Layout

glVertex2f(p2->getX(),p2->getY());   
\end_layout

\begin_layout Plain Layout

glVertex2f(p3->getX(),p3->getY());   
\end_layout

\begin_layout Plain Layout

glVertex2f(p4->getX(),p4->getY());   
\end_layout

\begin_layout Plain Layout

glEnd();   
\end_layout

\begin_layout Plain Layout

glFlush();      
\end_layout

\begin_layout Plain Layout

if(next > 1)
\end_layout

\begin_layout Plain Layout

{     
\end_layout

\begin_layout Plain Layout

float sum = sqrt(pow(p1->getY()-p2->getY(),2)+
\end_layout

\begin_layout Plain Layout

		     pow(p1->getX()-p2->getX(),2));     
\end_layout

\begin_layout Plain Layout

dif = sum/3;     
\end_layout

\begin_layout Plain Layout

vector<Punto*> lista;     
\end_layout

\begin_layout Plain Layout

Punto *c1 = new Punto(p1->getX()-(2*dif),(p1->getY()-(sum/2)));        
 
\end_layout

\begin_layout Plain Layout

Punto *c2 = new Punto(p1->getX()-(2*dif),p1->getY()+(2*dif));     
\end_layout

\begin_layout Plain Layout

Punto *c3 = new Punto(p1->getX()+(sum/2),p1->getY()+(2*dif));     
\end_layout

\begin_layout Plain Layout

Punto *c4 = new Punto(p2->getX()+(2*dif),p2->getY()+(2*dif));     
\end_layout

\begin_layout Plain Layout

Punto *c5 = new Punto(p2->getX()+(2*dif),(p2->getY()-(sum/2)));     
\end_layout

\begin_layout Plain Layout

Punto *c6 = new Punto(p3->getX()+(2*dif),p3->getY()-(2*dif));     
\end_layout

\begin_layout Plain Layout

Punto *c7 = new Punto(p4->getX()+(sum/2),p4->getY()-(2*dif));     
\end_layout

\begin_layout Plain Layout

Punto *c8 = new Punto(p4->getX()-(2*dif),p3->getY()-(2*dif));     
\end_layout

\begin_layout Plain Layout

lista.push_back(c1);     
\end_layout

\begin_layout Plain Layout

lista.push_back(c2);     
\end_layout

\begin_layout Plain Layout

lista.push_back(c3);      
\end_layout

\begin_layout Plain Layout

lista.push_back(c4);     
\end_layout

\begin_layout Plain Layout

lista.push_back(c5);     
\end_layout

\begin_layout Plain Layout

lista.push_back(c6);     
\end_layout

\begin_layout Plain Layout

lista.push_back(c7);    
\end_layout

\begin_layout Plain Layout

lista.push_back(c8);     
\end_layout

\begin_layout Plain Layout

for(int i = 0; i < lista.size(); i++)       
\end_layout

\begin_layout Plain Layout

{ 	
\end_layout

\begin_layout Plain Layout

Punto *c = lista.at(i);
\end_layout

\begin_layout Plain Layout

	draw(next-1, 	     
\end_layout

\begin_layout Plain Layout

new Punto((c->getX())-(dif/2),(c->getY())+(dif/2)),
\end_layout

\begin_layout Plain Layout

	     new Punto((c->getX())+(dif/2),(c->getY())+(dif/2)),
\end_layout

\begin_layout Plain Layout

	     new Punto((c->getX())+(dif/2),(c->getY())-(dif/2)),
\end_layout

\begin_layout Plain Layout

	     new Punto((c->getX())-(dif/2),(c->getY())-(dif/2)),dif,quitar); 
\end_layout

\begin_layout Plain Layout

     }   
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Section*
2.
 Arbol fractal
\end_layout

\begin_layout Standard

\lang spanish-mexico
Para este fractal usé también dos clases:
\end_layout

\begin_layout Standard

\lang spanish-mexico
La clase punto que definí e implementé previamente para el fractal de la
 Alfombra.
\end_layout

\begin_layout Standard

\lang spanish-mexico
La clase Arbol lo que contiene es un constructor que incluye 2 vértices.
 Los vértices que recibe marca la primer línea, que es el caso base de nuestra
 recursión.
 Dependiendo de que tantos niveles de nuestro fractal deseemos será las
 cantidades de veces que recursamos.
\end_layout

\begin_layout Standard

\lang spanish-mexico
En este caso, en nuestra clase y en su método draw sólo recibe 4 parámetros:
\end_layout

\begin_layout Standard

\lang spanish-mexico
Next es nivel de recursión que se hará en el fractal.
\end_layout

\begin_layout Standard

\lang spanish-mexico
2 puntos que son donde se encuentra nuestra línea actual.
\end_layout

\begin_layout Standard

\lang spanish-mexico
Y 
\begin_inset Quotes eld
\end_inset

Quitar
\begin_inset Quotes erd
\end_inset

 que es un booleano que, como en el fractal pasado, no dice si una vez que
 pasemos por un nivel, hay que dibujar de blanco el último nivel de la recursión.
\end_layout

\begin_layout Standard

\lang spanish-mexico
La única diferencia en este fractal con el otro es la rotación de las líneas.
 Usamos dos ángulos distintos para dale la forma a nuestro árbol (si se
 cambian estos ángulos, también cambia el tipo de árbol), ya que creamos
 nuestros ángulos en radiales, procedemos a hacer cálculos con funciones
 trigonométricas para obtener los nuevos dos puntos que serán las nuevas
 dos líneas que salen de mi punto más alto del árbol y recursamos con esos
 dos puntos.
\end_layout

\begin_layout Standard

\lang spanish-mexico
Para este fractal se usaron 2 archivos (3 incluyendo el main) y 2 clases,
 una previamente definida.
\end_layout

\begin_layout Subsection*
Arbol.h: Declaración de funciones y clases
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

/* ------------------------------------------------------------------- 
 
\end_layout

\begin_layout Plain Layout

* Arbol.h 
\end_layout

\begin_layout Plain Layout

* versión 1.0
\end_layout

\begin_layout Plain Layout

* Copyright (C) 2016   
\end_layout

\begin_layout Plain Layout

* José Ricardo Rodríguez Abreu,
\end_layout

\begin_layout Plain Layout

* Facultad de Ciencias, 
\end_layout

\begin_layout Plain Layout

* Universidad Nacional Autónoma de México, Mexico.
 
\end_layout

\begin_layout Plain Layout

*  
\end_layout

\begin_layout Plain Layout

* Este programa es software libre; se puede redistribuir  
\end_layout

\begin_layout Plain Layout

* y/o modificar en los términos establecidos por la  
\end_layout

\begin_layout Plain Layout

* Licencia Pública General de GNU tal como fue publicada 
\end_layout

\begin_layout Plain Layout

* por la Free Software Foundation en la versión 2 o  
\end_layout

\begin_layout Plain Layout

* superior.
  
\end_layout

\begin_layout Plain Layout

*  
\end_layout

\begin_layout Plain Layout

* Este programa es distribuido con la esperanza de que  
\end_layout

\begin_layout Plain Layout

* resulte de utilidad, pero SIN GARANTÍA ALGUNA; de hecho  
\end_layout

\begin_layout Plain Layout

* sin la garantía implícita de COMERCIALIZACIÓN o  
\end_layout

\begin_layout Plain Layout

* ADECUACIÓN PARA PROPÓSITOS PARTICULARES.
 Véase la  
\end_layout

\begin_layout Plain Layout

* Licencia Pública General de GNU para mayores detalles.
  
\end_layout

\begin_layout Plain Layout

*  
\end_layout

\begin_layout Plain Layout

* Con este programa se debe haber recibido una copia de la  
\end_layout

\begin_layout Plain Layout

* Licencia Pública General de GNU, de no ser así, visite el  
\end_layout

\begin_layout Plain Layout

* siguiente URL:  * http://www.gnu.org/licenses/gpl.html  
\end_layout

\begin_layout Plain Layout

* o escriba a la Free Software Foundation Inc.,  
\end_layout

\begin_layout Plain Layout

* 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
  
\end_layout

\begin_layout Plain Layout

* -------------------------------------------------------------------  */
 
\end_layout

\begin_layout Plain Layout

#include <cstdlib> 
\end_layout

\begin_layout Plain Layout

#include <cmath> 
\end_layout

\begin_layout Plain Layout

#include <iostream> 
\end_layout

\begin_layout Plain Layout

#include <GL/glew.h> 
\end_layout

\begin_layout Plain Layout

#include "Alfombra.cpp"
\end_layout

\begin_layout Plain Layout

#ifdef __APPLE__ 
\end_layout

\begin_layout Plain Layout

# define __gl_h_ 
\end_layout

\begin_layout Plain Layout

# define GL_DO_NOT_WARN_IF_MULTI_GL_VERSION_HEADERS_INCLUDED 
\end_layout

\begin_layout Plain Layout

#endif 
\end_layout

\begin_layout Plain Layout

//#include "Dependencies
\backslash
freeglut
\backslash
freeglut.h"
\end_layout

\begin_layout Plain Layout

// cambienlo de acuerdo a como ustedes lo tengan 
\end_layout

\begin_layout Plain Layout

#include <OpenGL/gl3.h> 
\end_layout

\begin_layout Plain Layout

#define __gl_h_ 
\end_layout

\begin_layout Plain Layout

#include <GL/freeglut.h>
\end_layout

\begin_layout Plain Layout

#include <GL/glut.h> 
\end_layout

\begin_layout Plain Layout

#include <vector>
\end_layout

\begin_layout Plain Layout

//#include "Dependencies
\backslash
glew
\backslash
glew.h"
\end_layout

\begin_layout Plain Layout

//cambienlo de acuerdo a como ustedes lo tengan 
\end_layout

\begin_layout Plain Layout

//#include "Dependencies
\backslash
freeglut
\backslash
freeglut.h"
\end_layout

\begin_layout Plain Layout

// cambienlo de acuerdo a como ustedes lo tengan
\end_layout

\begin_layout Plain Layout

using namespace std;
\end_layout

\begin_layout Plain Layout

/**  
\end_layout

\begin_layout Plain Layout

* Definimos nuestra clase alfombra que será el fractal.
  
\end_layout

\begin_layout Plain Layout

*/ 
\end_layout

\begin_layout Plain Layout

class Arbol {
\end_layout

\begin_layout Plain Layout

  /**    
\end_layout

\begin_layout Plain Layout

* Aquí van los atributos y los métodos privados.
    
\end_layout

\begin_layout Plain Layout

*/  
\end_layout

\begin_layout Plain Layout

private:   
\end_layout

\begin_layout Plain Layout

unsigned int level;   
\end_layout

\begin_layout Plain Layout

Punto *p1,*p2;   
\end_layout

\begin_layout Plain Layout

void draw_arbol(int next,Punto *p1, Punto *p2,bool quitar);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  /**
\end_layout

\begin_layout Plain Layout

   * Métodos contructores y de la clase.
    
\end_layout

\begin_layout Plain Layout

*/  
\end_layout

\begin_layout Plain Layout

public:   
\end_layout

\begin_layout Plain Layout

Arbol(int level,Punto *p1, Punto *p2);   
\end_layout

\begin_layout Plain Layout

int getLevel_arbol();   
\end_layout

\begin_layout Plain Layout

void setLevel_arbol(int level);     
\end_layout

\begin_layout Plain Layout

void draw_arbol(int next);   
\end_layout

\begin_layout Plain Layout

void quita_ultimo_nivel_arbol(int next); 
\end_layout

\begin_layout Plain Layout

}; //Fin de Arbol.h 
\end_layout

\end_inset


\end_layout

\begin_layout Subsection*
Arbol.cpp (Implementación de draw)
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

/**  
\end_layout

\begin_layout Plain Layout

* Método privado para dibujar los niveles del fractal.
  
\end_layout

\begin_layout Plain Layout

*/ 
\end_layout

\begin_layout Plain Layout

void Arbol::draw_arbol(int next,Punto *p1, Punto *p2,bool quitar) 
\end_layout

\begin_layout Plain Layout

{   
\end_layout

\begin_layout Plain Layout

if(next == 0)    
\end_layout

\begin_layout Plain Layout

return;   
\end_layout

\begin_layout Plain Layout

if(quitar && next == 1)     
\end_layout

\begin_layout Plain Layout

{     
\end_layout

\begin_layout Plain Layout

glColor3f(255,255,255);     
\end_layout

\begin_layout Plain Layout

}   
\end_layout

\begin_layout Plain Layout

else     
\end_layout

\begin_layout Plain Layout

{     
\end_layout

\begin_layout Plain Layout

glColor3f(0,0,0);     
\end_layout

\begin_layout Plain Layout

}   
\end_layout

\begin_layout Plain Layout

glBegin(GL_LINES);        
\end_layout

\begin_layout Plain Layout

glVertex2f(p1->getX(),p1->getY());   
\end_layout

\begin_layout Plain Layout

glVertex2f(p2->getX(),p2->getY());   
\end_layout

\begin_layout Plain Layout

glEnd();   
\end_layout

\begin_layout Plain Layout

glFlush();      
\end_layout

\begin_layout Plain Layout

if(next > 1){     
\end_layout

\begin_layout Plain Layout

vector<Punto*> lista;
\end_layout

\begin_layout Plain Layout

float pi = 3.14159265;     
\end_layout

\begin_layout Plain Layout

float ang1 = (60) * pi / 180;     
\end_layout

\begin_layout Plain Layout

float ang2 = (300) * pi / 180;     
\end_layout

\begin_layout Plain Layout

float factor = 0.6;     
\end_layout

\begin_layout Plain Layout

float x = (p2->getX()-p1->getX());     
\end_layout

\begin_layout Plain Layout

float y = (p2->getY()-p1->getY());     
\end_layout

\begin_layout Plain Layout

float a1 = (cos(ang1) * x) - (sin(ang1) * y);     
\end_layout

\begin_layout Plain Layout

float b1 = (sin(ang1) * x) + (cos(ang1) * y);    
\end_layout

\begin_layout Plain Layout

float a2 = (cos(ang2) * x) - (sin(ang2) * y);     
\end_layout

\begin_layout Plain Layout

float b2 = (sin(ang2) * x) + (cos(ang2) * y);
\end_layout

\begin_layout Plain Layout

   
\end_layout

\begin_layout Plain Layout

Punto *np1 = new Punto(p2->getX()+(factor*a1),p2->getY()+((factor*b1)));
     
\end_layout

\begin_layout Plain Layout

Punto *np2 = new Punto(p2->getX()+(factor*a2),p2->getY()+((factor*b2)));
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

   lista.push_back(np1);     
\end_layout

\begin_layout Plain Layout

lista.push_back(np2);    
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

for(int i = 0; i < lista.size(); i++) 
\end_layout

\begin_layout Plain Layout

     { 	
\end_layout

\begin_layout Plain Layout

Punto *l = lista.at(i); 	
\end_layout

\begin_layout Plain Layout

draw_arbol(next-1,p2,l,quitar);       
\end_layout

\begin_layout Plain Layout

}  
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

} //Fin de Arbol.cpp 
\end_layout

\end_inset


\end_layout

\end_body
\end_document
